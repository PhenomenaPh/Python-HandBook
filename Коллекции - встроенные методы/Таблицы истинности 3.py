from itertools import product

# Сначала мы парсим входные данные, заменяя каждую открывающуюся и закрывающуюся скобку на ту же скобку с пробелом, 
# чтобы упростить разделение.
data = input().replace(' (', ' ( ').replace(') ', ' ) ').split()

# Извлекаем все переменные из входных данных и сортируем их в алфавитном порядке.
variables = sorted(set(value for value in data if value.isupper()))

# Устанавливаем приоритеты для каждого из операторов. Чем больше число, тем выше приоритет.
symbols = {
    'not': 6,
    'and': 5,
    'or': 4,
    '^': 3,
    '->': 2,
    '~': 1,
}

# Создаем два стека: один для операторов и один для операндов.
operators = []
operands = []

# Перебираем каждый элемент в входных данных
for i in data:
    # Если элемент является оператором
    if i in symbols:
        # Пока в стеке есть операторы и приоритет текущего оператора меньше или равен приоритету последнего оператора в стеке,
        # извлекаем операторы из стека и добавляем их в список операндов
        while operators and symbols.get(operators[-1], 0) >= symbols[i]:
            operands.append(operators.pop())
        # Добавляем текущий оператор в стек
        operators.append(i)
    # Если элемент - открывающая скобка, добавляем его в стек операторов
    elif i == '(':
        operators.append(i)
    # Если элемент - закрывающая скобка, извлекаем все операторы из стека до открывающей скобки и добавляем их в список операндов.
    # Затем удаляем открывающую скобку из стека.
    elif i == ')':
        while operators[-1] != '(':
            operands.append(operators.pop())
        operators.pop()
    # Если элемент - операнд (переменная), добавляем его в список операндов.
    else:
        operands.append(i)

# Извлекаем все оставшиеся операторы из стека и добавляем их в список операндов.
while operators:
    operands.append(operators.pop())

# Выводим заголовок для таблицы истинности.
print(f"{' '.join(variables)} F")

# Генерируем все возможные комбинации значений переменных (т.е. все возможные строки таблицы истинности)
for i in product([0, 1], repeat=len(variables)):
    # Создаем словарь, который связывает каждую переменную с ее текущим значением.
    env = dict(zip(variables, i))
    # Создаем стек для вычисления выражения в обратной польской нотации.
    stack = []

    # Перебираем каждый токен в выражении
    for token in (env[i] if i in env else i for i in operands):
        # Если токен - оператор, выполняем соответствующую операцию с последними значениями в стеке.
        if token in symbols:
            if token == '^':
                # Исключающее ИЛИ (XOR) - результат истинен, если значения операндов различны.
                b = stack.pop()
                a = stack.pop()
                stack.append(a != b)
            elif token == '->':
                # Импликация (IF THEN) - результат истинен, если первый операнд ложен или второй операнд истинен.
                b = stack.pop()
                a = stack.pop()
                stack.append(not a or b)
            elif token == '~':
                # Эквивалентность (IFF) - результат истинен, если оба операнда имеют одинаковые значения.
                b = stack.pop()
                a = stack.pop()
                stack.append(a == b)
            elif token == 'not':
                # Отрицание (NOT) - результат является обратным значением операнда.
                stack.append(not stack.pop())
            elif token == 'and':
                # Логическое И (AND) - результат истинен, если оба операнда истинны.
                b = stack.pop()
                a = stack.pop()
                stack.append(a and b)
            elif token == 'or':
                # Логическое ИЛИ (OR) - результат истинен, если хотя бы один из операндов истинен.
                b = stack.pop()
                a = stack.pop()
                stack.append(a or b)
        # Если токен - операнд, добавляем его в стек.
        else:
            stack.append(token)

    # Выводим текущую строку таблицы истинности и результат вычисления выражения.
    print(f'{" ".join(map(str, i))} {int(stack[-1])}')



